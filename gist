<div> {stars} </stars> stars is just an array with html elements, React will render it as html anyway
() => ({options : []}) returning an object in an arrow function
!! turns values to true and undefined to false
{options, defaultChoice, name} = this.state distracting the state object into vars
d

BEM naming conventions for styles
use normalize css for your style
use scss functions as darken($purple, 10%);
word-break for breaking long words

const { location = 'Kemerovo', tem: temperature} = this.state renaming while destructing, adding default values
cloning an object using spread operator {...user}
overwriting existing object's properties with new values return { ...expense, ...action.updates }
OR { ...state, sotBy: 'date'} l 94, 95
 <WrappedComponent {....props}/> pass props without specifying

 {this.authButton()} you can put class's methods inside render() and locat some JSX in those methods (button in this case);
 import * as actions from '../actions' imports all actions in all files in the actions folder
 use this.context in class components (similar to this., but accessable on all tree of components) lec 44
 use higher order components for authentication ?????
 use lifecycle methods like componentWillMount() and componentWillUpdate(nextProps) for authentication and redirects
 this.props.users.map(this.renderUser) instead of this.props.users.map(user => this.renderUser(user))
 const {handleSubmit, fields : {email, password}} = this.props;
 if you have nested routes (as in the advanced course) use {this.props.children} to show children in the main rout (app.js)
 return [<li></li>, <li></li>] array of jsx without wrapping div
 to validate an input use idea of "touched" (focusOut)
 this.props.children for accessing html in parent's body


 when writing server code always set response {error : 'You must provide password'}, it will simplify debugging on th front-end and also show a relevant error message
 componentWillMount() and others are like action filters in PHP
 componenetDidCatch() for showing error messages to the user without crashing of app
 create Modal windows with ReactDOM.CreatePortal()
 you can access old state in setState and you can return null inside to prevent rerendering

 Css
 translateX




LOADING GIF:
state.loading = false; then componentWillReceiveProps(){
this.setStae({loading:true});
setTimeout(() => {
this.setState({loading:false});
},500)

and in component: if this.state.loading return <gif>Loading</gif> else return normal component

